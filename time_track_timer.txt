

#--------Main Frame-------

import tkinter as tk
import time
import os #to get json files
import threading

session_name = None  #not sure if this is necessary. why would I need to be explicit with this?
session_active = False
break_active = False
break_start = None  
break_session =
session_idle = False #starts out false since wrapper called when session active
last_user_input = None #timestamp of last user input during active session
settings_file = "settings.json"
data_file = "data.json"  #onefile with all the session datas




def get_settings():
	#set default settings
	default_settings = {"idle_threshold" : 60, "idle_break_threshold" : 300}
	#if settings file doesn't exist create it
	if not os.path.exists(settings_file):
		with open(settings_file, "w") as f
			json.dump(default_settings, f)
		return default_settings
	#try to get settings file, example of EAFP
	try:	
		with open(settings_file, "r") as f
			return json.load(f)
	except Exception as e:
		print(f"failed to read settings file: {e}")
		return default_settings
	


def start_session(sphere=default):
	sphere_name = sphere
	session_start = time.perf_counter()
	date = today() #date
	timestamp = now() #time
	#session name is the session_start(sec) and date
	session_name = session_start, date

	#python dict for json
	session_dict = {session_name : {"session_start" : session_start, "sphere_name" : sphere_name, "date" : date, "timestamp" : timestamp}}

	#start session if no session active
	if session_active:
		return  #don't start a session on an active session
	else:
		#set session active
		session_active = True
		#use EAFP philopsophy to try to open data file except to write, this creates if doesn't exist 
		# add new session with session_name, sphere_name
		try:
			with open(data_file, "w") as f
				json.dump(session_dict, f)
			return session_dict
		except Exception as e:
			print(f"session was not saved to data file: {e}")
			return session_dict



def end_session():
	
	#store timestamp locally and in JSON

def start_break():

	#store timestamp locally and in JSON

def end_break():

	#store timestamp locally and in JSON

def session_idle(settings):
	#tracks input from keyboard and mouse sets time stamp to last action
	while True:
		#timestamp of input, not sure of syntax
		last_user_input = os.input.time.perf_counter() if true else None
		if last_user_input < time.perf_counter() - settings["idle_threshold"]:
			session_idle = True 
			start_idle_input = last_user_input #clarity in reading
			idle_data(session_idle, start_idle_input)
			while session_idle: #loop while session_idle true, using the same thread
				#not sure of syntax, listen for any input
				end_idle_input = os.input.time.perf_counter() if true else None
				if end_idle_input:
					session_idle = False
					session_idle_thread.join(timeout=1.0)  #end the session idle thread
					#seems like maybe just return ends the thread automatically without explicitly calling join or clear
					return session_idle 
				time.sleep(0.1) 
	
		time.sleep(0.1) #to not burn out cpu

	
#wrapper function to send start_idle_input, session_idle, end_idle_input
def idle_data(session_idle, start_idle_input, end_idle_input=None):
	return session_idle, start_idle_input, end_idle_input
	




#start session button calls start_session function
start_new = tk.Button(command=start_session)

#save to json file anytime function is called
#save to json file every 5 min as auto back up

#dashboard above timer by sphere
#average time by sphere actions and break actions per last week, last two weeks, work week,


#main guard
if __main__ == "__name__":
	#get assign settings json sting to python dict
	settings = get_settings()

	#threading event for session_idle tracking 
	session_idle_thread = threading.Thread(target=session_idle, arg=(settings) daemon=true)

	#while true loop to keep in runtime
	while True:
		# show clock timer running when session starts
		if session_active
			if not break_active:
				#have clock show tracking incrementally on session timer
				#show 0 on break timer
				#call session_idle function with thread
				session_idle_thread.start()
				#start break if idle is longer than the idle_break_threshold 
				if start_idle_input < time.perf_counter() - settings["idle_break_threshold"]:
					start_break()
					
			else:
				#show time paused at time elapsed on session timer
				#have clock show tracking incrementally on break timer
		else:
			#show 0 on both timers
		time.sleep(0.1)



#--------Settings Frame-------
	#goal for the sphere(session name)
	#goal for the action by sphere
	#can add spheres, projects active-actions and break-actions
	#default session sphere
	#default time each action takes

#--------Evaluate Frame-------
	# Agent API(s) for analyisis
	# deafualt customizable questionaire per session name (task)
	#user questionaire providing the data to answer the question
	#side by side comparison of self analysis & multiple agent summaries using form questions
	#summary of all agent analyisis that agree and dissenting opinion
	#print readable by filter (all, session, date, actions)
	#ability to edit each field from this frame


#--------Completed Frame-------
	#opens when session is completed after calling end_session function
	#reads setting file to show deault settings for sphere(coding),projects(learning, codingproject1, codingproject2), actions(bathroom, chores)
	#shows the session with all the data time working time on break, idle time, 
 	#each time period(eg start>break) has default settings data spheres projects and actions
	#add new for session , project action sphere
	#saves to settin file once saved
	#if default time for action is set then populate in time/percentage of break
	# divy up  the  time for active work and break
	#each break action and session action has a text box to add why
	#can customize time of break for actions either by time or percentage
	#actions autopopulate by text or dropdown
	#checkbox for if really necessary to do action now and text box for elaboration

	

	


Thoughts and Questions:
	
any reason to just do this as a class so i don't have to pass around variables
	but what about multiple break sessions?
		we can just store it on a list with the abstraction
thinking of scaling to see if interest with the concept of MVP in mind
	I like the idea of running locally for my own use but is there a way to build wiht  the ability to run on browser with minimal changes?
	or turn into an app? 
	what is more practical and likely  to get people to test it out?
	am i just using python because it is what i am most familar with right now?
		partly yes but i do want the program to function as a exe to see in my mindowstask bar, is that a problem for scalablity?
thinking of what value this provides
	is what i am doing make a difference?
	worth it?
	time align
		is it moving towards my goal for the action of in this sphere (task)
		this alligns time towards my goal. seeing the blindspots
storing data
	it seems that nosql is the way to go with this project since rarely altering saved data only pulling it up to read
	it seems that just one JSON file would be enough.
		is there a limit to how much data can be stored in JSON file?
		Any reason to create separated files regularly?
class or functions
	seems that the session logic lends itself to class so that I don't have to pass around data in functions
	might not make any difference at all.


